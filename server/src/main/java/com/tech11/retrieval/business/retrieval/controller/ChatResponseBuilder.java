package com.tech11.retrieval.business.retrieval.controller;

import java.time.Instant;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.UUID;

import jakarta.enterprise.context.ApplicationScoped;

import com.tech11.retrieval.business.retrieval.entity.ChatMessageText;
import com.tech11.retrieval.business.retrieval.entity.ChatResponseDTO;
import com.tech11.retrieval.business.retrieval.entity.ChatThreadEntry;
import com.tech11.retrieval.business.retrieval.entity.Citation;
import com.tech11.retrieval.business.retrieval.entity.ConversationSession;
import com.tech11.retrieval.business.retrieval.entity.DocumentChunkDTO;
import com.tech11.retrieval.business.retrieval.entity.DocumentChunkMetadataDTO;

/**
 * Builder for creating chat response objects.
 */
@ApplicationScoped
public class ChatResponseBuilder {

	/**
	 * Builds a complete ChatResponseDTO based on the assistant's answer, the document chunks used for citations/data
	 * points, and the current conversation session.
	 *
	 * @param answer
	 *     the answer generated by the chat model
	 * @param similarChunksDTOs
	 *     the document chunks associated with the query
	 * @param session
	 *     the current conversation session
	 * @return a fully built ChatResponseDTO
	 */
	public ChatResponseDTO buildChatResponse(final String answer,
			final List<DocumentChunkDTO> similarChunksDTOs,
			final ConversationSession session) {
		final ChatThreadEntry entry = buildChatThreadEntry(answer, similarChunksDTOs);
		final ChatResponseDTO responseDTO = new ChatResponseDTO();
		responseDTO.setResponses(Collections.singletonList(entry));
		responseDTO.setSessionState(Collections.singletonMap("sessionId", session.getSessionId()));
		return responseDTO;
	}

	/**
	 * Constructs the ChatThreadEntry representing the assistant's response.
	 *
	 * @param answer
	 *     the answer text
	 * @param similarChunksDTOs
	 *     the document chunks for building citations and data points
	 * @return a ChatThreadEntry instance
	 */
	private ChatThreadEntry buildChatThreadEntry(final String answer,
			final List<DocumentChunkDTO> similarChunksDTOs) {
		final ChatThreadEntry entry = new ChatThreadEntry();
		entry.setId(UUID.randomUUID().toString());
		entry.setTimestamp(Instant.now().toString());
		entry.isUserMessage(false); // Indicates an assistant message

		final ChatMessageText messageText = new ChatMessageText();
		messageText.setValue(answer);
		messageText.setFollowingSteps(Collections.emptyList());
		entry.setText(Collections.singletonList(messageText));

		entry.setFollowupQuestions(Collections.emptyList());
		entry.setCitations(buildCitations(similarChunksDTOs));
		entry.setDataPoints(extractDataPoints(similarChunksDTOs));
		entry.setThoughts(null);
		return entry;
	}

	/**
	 * Builds a list of citations from the document chunks.
	 *
	 * @param chunks
	 *     the document chunks DTO
	 * @return a list of Citation objects
	 */
	private List<Citation> buildCitations(final List<DocumentChunkDTO> chunks) {
		final List<Citation> citations = new ArrayList<>();
		for (final DocumentChunkDTO chunk : chunks) {
			final Citation citation = new Citation();
			String relatedHeading = "";
			final DocumentChunkMetadataDTO metadata = chunk.getMetadata();
			if (metadata != null) {
				final String sourceHeading = metadata.getSourceHeading();
				final String pageHeader = metadata.getPageHeader();
				relatedHeading = (sourceHeading != null) ? sourceHeading : (pageHeader != null ? pageHeader : "");
			}
			citation.setRelatedHeading(relatedHeading);
			citation.setId(chunk.getDocumentLabel());
			citation.setPageNumber(metadata != null ? Integer.parseInt(metadata.getPageNumber()) : null);
			citations.add(citation);
		}
		return citations;
	}

	/**
	 * Extracts data points (for example, source headings) from the document chunks.
	 *
	 * @param chunks
	 *     the document chunks DTO
	 * @return a list of data point strings
	 */
	private List<String> extractDataPoints(final List<DocumentChunkDTO> chunks) {
		final List<String> dataPoints = new ArrayList<>();
		for (final DocumentChunkDTO chunk : chunks) {
			if (chunk.getMetadata() != null && chunk.getMetadata().getSourceHeading() != null) {
				dataPoints.add(chunk.getMetadata().getSourceHeading());
			}
		}
		return dataPoints;
	}
}
